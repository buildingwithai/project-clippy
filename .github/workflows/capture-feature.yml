name: Capture Feature

on:
  workflow_dispatch:
    inputs:
      title:
        description: "Short feature title (e.g., Overlay Modal prioritization)"
        required: true
        type: string
      summary:
        description: "1-3 sentences describing the feature"
        required: false
        type: string
        default: "Backfilled feature capture."
      keywords:
        description: "Comma-separated keywords to search in the codebase (e.g., modal, overlay, snippet, domain, favicon)"
        required: false
        type: string
        default: ""
      links:
        description: "Comma-separated links (branches, commits, docs)"
        required: false
        type: string
        default: ""
      status:
        description: "Project Status to set (Planned, In Progress, Done)"
        required: false
        type: string
        default: "Planned"
      labels:
        description: "Comma-separated labels to add"
        required: false
        type: string
        default: "feature"
      project_owner:
        description: "Owner login of the Project (user or org)"
        required: true
        type: string
        default: "buildingwithai"
      project_number:
        description: "Project number"
        required: true
        type: number
        default: 1

permissions:
  contents: read
  issues: write

jobs:
  capture:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create Feature issue, add labels, add to Project, set Status
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_TOKEN }}
          script: |
            const title = '${{ inputs.title }}'.trim();
            const summary = '${{ inputs.summary }}'.trim();
            const rawKeywords = '${{ inputs.keywords }}'.trim();
            const links = '${{ inputs.links }}'.trim();
            const statusInput = ('${{ inputs.status }}' || 'Planned').trim();
            const labelsInput = ('${{ inputs.labels }}' || 'feature').trim();
            const projectOwner = ('${{ inputs.project_owner }}' || 'buildingwithai').trim();
            const projectNumber = parseInt('${{ inputs.project_number }}', 10);

            if (!title) {
              core.setFailed('Title is required');
              return;
            }

            // Search code for keyword references
            const keywords = rawKeywords ? rawKeywords.split(',').map(s => s.trim()).filter(Boolean) : [];
            const fs = require('fs');
            const path = require('path');
            const refs = [];
            const exts = new RegExp('\\.(ts|tsx|js|jsx|md|yml|yaml|json|css)$', 'i');
            function walk(dir) {
              let entries;
              try { entries = fs.readdirSync(dir, { withFileTypes: true }); } catch { return; }
              for (const e of entries) {
                const p = path.join(dir, e.name);
                if (e.isDirectory()) {
                  // skip some heavy dirs
                  if (/^\.git$|^dist$|^node_modules$/.test(e.name)) continue;
                  walk(p);
                } else if (exts.test(e.name)) {
                  if (!keywords.length) continue;
                  let content = '';
                  try { content = fs.readFileSync(p, 'utf8'); } catch { continue; }
                  let score = 0; const matched = new Set();
                  for (const k of keywords) {
                    if (!k) continue;
                    const safe = k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                    const m = content.match(new RegExp(safe, 'ig'));
                    if (m) { score += m.length; matched.add(k); }
                  }
                  if (score > 0) refs.push({ path: p, score, matched: Array.from(matched) });
                }
              }
            }
            try { walk(process.cwd()); } catch (e) { core.warning(`Code search failed: ${e.message}`); }
            refs.sort((a,b) => b.score - a.score);
            const topRefs = refs.slice(0, 10).map(r => `- ${r.path} (matches: ${r.matched.join(', ')})`).join('\n');

            // Assemble issue body with enforced sections
            const linksBlock = links
              ? links.split(',').map(s => s.trim()).filter(Boolean).map(u => `- ${u}`).join('\n')
              : '-';

            let body = '';
            body += `${summary || 'Backfilled feature capture.'}\n\n`;
            body += `Links\n${linksBlock}\n\n`;
            body += `Goal\n\n[Describe the single outcome this feature seeks to achieve]\n\n`;
            body += `Audience & Value\n\nCustomer Success\n- Problem:\n- Value:\n- Proof:\n\nSales\n- Problem:\n- Value:\n- Proof:\n\nRecruiting\n- Problem:\n- Value:\n- Proof:\n\n`;
            body += `User Stories (by audience)\n\nCustomer Success\n- Story:\n- Acceptance:\n  - [ ] ...\n\nSales\n- Story:\n- Acceptance:\n  - [ ] ...\n\nRecruiting\n- Story:\n- Acceptance:\n  - [ ] ...\n\n`;
            body += `Click-by-Click (How to use)\n\n1. ...\n2. ...\n3. ...\n\n`;
            body += `Acceptance Criteria\n\n- [ ] ...\n- [ ] ...\n- [ ] ...\n\n`;
            body += `Roadblocks & Attempts\n\nErrors/Symptoms:\n- ...\nAttempts:\n- ...\nWhy Failed:\n- ...\nWhat Worked:\n- ...\n\n`;
            body += `Technical Notes\n\n- Code areas:\n${topRefs || '-'}\n- Security/CSP:\n- Perf:\n\n`;
            body += `Release Notes & Rollback\n\n- Release:\n- Rollback:\n\n`;
            body += `Artifacts\n\n- GIF/Screens:\n- PRs:\n- Related:\n`;

            // Create issue
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Feature: ${title}`,
              body,
            });

            // Add labels (ensure 'feature' exists)
            const labels = labelsInput.split(',').map(s => s.trim()).filter(Boolean);
            if (labels.length) {
              try {
                await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number, labels });
              } catch (e) {
                if ((e.status === 404) || /not found/i.test(e.message)) {
                  try {
                    await github.rest.issues.createLabel({ owner: context.repo.owner, repo: context.repo.repo, name: 'feature', color: '0E8A16', description: 'Feature work' });
                  } catch (_) {}
                  try {
                    await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number, labels });
                  } catch (e2) { core.warning(`Unable to add labels: ${e2.status || ''} ${e2.message}`); }
                } else {
                  core.warning(`Add labels error: ${e.status || ''} ${e.message}`);
                }
              }
            }

            // Resolve project owner type
            let ownerType = 'User';
            try {
              const { data: ownerInfo } = await github.rest.users.getByUsername({ username: projectOwner });
              ownerType = ownerInfo.type === 'Organization' ? 'Organization' : 'User';
            } catch (e) {
              core.warning(`Failed to resolve owner type for ${projectOwner}, defaulting to User: ${e.status || ''} ${e.message}`);
            }

            // Query project + Status field
            const projectQuery = ownerType === 'Organization'
              ? `query($login: String!, $number: Int!) {\n  organization(login: $login) {\n    projectV2(number: $number) {\n      id\n      fields(first: 50) {\n        nodes {\n          ... on ProjectV2FieldCommon { id name }\n          ... on ProjectV2SingleSelectField { id name options { id name } }\n        }\n      }\n    }\n  }\n}`
              : `query($login: String!, $number: Int!) {\n  user(login: $login) {\n    projectV2(number: $number) {\n      id\n      fields(first: 50) {\n        nodes {\n          ... on ProjectV2FieldCommon { id name }\n          ... on ProjectV2SingleSelectField { id name options { id name } }\n        }\n      }\n    }\n  }\n}`;

            const projData = await github.graphql(projectQuery, { login: projectOwner, number: projectNumber });
            const project = ownerType === 'Organization' ? projData.organization?.projectV2 : projData.user?.projectV2;

            if (!project?.id) {
              core.warning('Project not found; skipping Project add.');
              return;
            }

            const statusField = (project.fields?.nodes || []).find(f => f?.name === 'Status' && f.options);
            let option = statusField?.options?.find(o => (o.name || '').toLowerCase() === statusInput.toLowerCase());
            if (!option && statusField?.options?.length) {
              option = statusField.options.find(o => /planned/i.test(o.name)) || statusField.options[0];
            }

            // Add to project
            let itemId = null;
            try {
              const addRes = await github.graphql(
                `mutation($projectId: ID!, $contentId: ID!) {\n  addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {\n    item { id }\n  }\n}`,
                { projectId: project.id, contentId: issue.node_id }
              );
              itemId = addRes?.addProjectV2ItemById?.item?.id;
            } catch (e) {
              core.warning(`addProjectV2ItemById failed (possibly already added): ${e?.errors?.[0]?.message || e.message}`);
            }

            // Set Status if possible
            if (itemId && option) {
              try {
                await github.graphql(
                  `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {\n  updateProjectV2ItemFieldValue(input: { projectId: $projectId, itemId: $itemId, fieldId: $fieldId, value: { singleSelectOptionId: $optionId }}) {\n    clientMutationId\n  }\n}`,
                  { projectId: project.id, itemId, fieldId: statusField.id, optionId: option.id }
                );
              } catch (e) {
                core.warning(`Status update failed: ${e?.errors?.[0]?.message || e.message}`);
              }
            }

            // Auto-close if Status=Done
            if ((statusInput || '').toLowerCase() === 'done') {
              try {
                await github.rest.issues.update({ owner: context.repo.owner, repo: context.repo.repo, issue_number: issue.number, state: 'closed', state_reason: 'completed' });
              } catch (e) {
                core.warning(`Auto-close failed: ${e.status || ''} ${e.message}`);
              }
            }

            core.notice(`Captured feature as issue #${issue.number} with title 'Feature: ${title}' and Status='${statusInput}'.`)
